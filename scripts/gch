#!/usr/bin/python
# Script that automatically checks (and pull if possible) all git repos as defined in the
# `load_repositories_definition function. The script search recursively in `recursive_repos_dirs`
# for git repositories and add repositories in `repos` to it.
#
# Add pattern (substring) in exclude_pattern to exclude repos.
#
# Inspired from https://github.com/Gorzen/.files/blob/master/.local/bin/dirty-git-epfl

import os, sys, tty, termios
import re
import subprocess as sp
import multiprocessing
import numpy as np

def load_repositories_definition():
    base_path = os.environ["HOME"]
    recursive_repo_dirs = [f"documents/magma"]
    repo_dirs = [os.environ['PASSWORD_STORE_DIR'], os.environ['RICE_PATH']]
    exclude_patterns = []

    return base_path, repo_dirs, recursive_repo_dirs, exclude_patterns

# Colors
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKCYAN = '\033[96m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'

def run_command(cmd, cwd="."):
    stdout, _ = sp.Popen(
        cmd.split(" "), stdout=sp.PIPE, stderr=sp.STDOUT, cwd=cwd
    ).communicate()

    return stdout.decode("utf-8")

def check_relative_path(base_path, repos):
    repos = [repo if os.path.isabs(repo) else os.path.join(base_path, repo) for repo in repos]

    return repos

def get_repos(base_path, repo_paths, recursive_repo_dirs):
    repo_paths = check_relative_path(base_path, repo_paths)
    recursive_repo_dirs = check_relative_path(base_path, recursive_repo_dirs)

    # Find repos
    found_repos = []
    find_git_repo_cmd = "find {} -name '.git' -type d | sed 's/\.git$//'"
    for dir_ in recursive_repo_dirs:
        stream = os.popen(find_git_repo_cmd.format(dir_))
        output = stream.read().split('\n')
        found_repos += list(filter(None, output))

    all_repos = repo_paths + found_repos

    return all_repos


def filter_repos(repos, exclude_patterns):
    # Filter non-directory repos
    repos = list(filter(os.path.isdir, repos))

    # Remove repo with matching pattern in exclude_patterns
    repos = list(filter(lambda repo: np.all([pat not in repo for pat in exclude_patterns]), repos))

    return repos


def fetch_repos(repos):
    jobs = []
    for repo in repos:
        process = multiprocessing.Process(target=run_command, args=("git fetch", repo))
        jobs.append(process)

    # Start the threads (i.e. calculate the random number lists)
    for j in jobs:
        j.start()

    # Ensure all of the threads have finished
    printProgressBar(0, len(jobs))
    for i, j in enumerate(jobs):
        j.join()
        printProgressBar(i + 1, len(jobs))


# Print iterations progress
def printProgressBar(iteration, total, length=60, fill="â–ˆ"):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
    """
    percent = "%.1f" % (100 * iteration / float(total))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + "-" * (length - filledLength)
    print("\rProgress: |%s| %s%% Complete" % (bar, percent), end="\r")
    # Print New Line on Complete
    if iteration == total:
        print('\n')

def ask_input(prompt):
    print(prompt, end=' ', flush=True)
    # key_read = readchar.readkey()
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        key_read = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

    return key_read

def print_dirty_repos(base_path, repos):
    dirty_report = []
    # Longest repo string length
    max_length = len(max(repos, key=len))
    all_clean = True

    for repo in repos:
        repo_short_name = re.sub(rf'^{base_path}/', '', repo)

        git_branch = run_command("git branch -vv --color=always", cwd=repo)
        git_branch = re.sub(r'\][^\n]*', ']', git_branch)
        git_current_branch = '\n'.join(re.findall(r'\*.*behind.*$', git_branch))
        git_other_branches = '\n'.join(re.findall(r'[^\n]\s*.*behind.*', git_branch))
        git_status = run_command("git -c color.status=always status -sb", repo)

        # Check status
        dirty_status = git_status.count("\n") > 1
        dirty_ahead = "ahead" in git_branch
        dirty_behind_current_branch = "behind" in git_current_branch
        dirty_behind_other_branches = "behind" in git_other_branches

        # Pull if just behind remote
        pulled = False
        if dirty_behind_current_branch and not dirty_ahead and not dirty_status:
            prompt = f"Pull {FAIL}{BOLD}{UNDERLINE}{repo_short_name}:{ENDC}? [y/n]:"
            key_read = ask_input(prompt)
            print(key_read)
            if key_read == 'y' or key_read == 'Y':
                print('Pulling ...')
                stream = sp.Popen(f"cd {repo} && git pull", shell=True)
                pulled = stream.wait() == 0
                pulled
            print()
        dirty_behind_current_branch = dirty_behind_current_branch and not pulled
        dirty_behind = dirty_behind_other_branches or dirty_behind_current_branch
        dirty_branch = dirty_behind or dirty_ahead
        dirty_repo = dirty_status or dirty_branch
        all_clean = all_clean and not dirty_repo

        # Update dirty report
        if dirty_repo:
            dirty_report.append(f"{FAIL}{BOLD}{UNDERLINE}{repo_short_name}:{ENDC}")

            if dirty_branch:
                dirty_report.append(git_branch)

            if dirty_status:
                dirty_report.append(git_status)

    if all_clean:
        print("All clean!")
    else:
        print("Dirty report")
        print('\n'.join(dirty_report))


if __name__ == "__main__":
    base_path, repo_paths, recursive_repo_dirs, exclude_patterns = load_repositories_definition()
    all_repos = get_repos(base_path, repo_paths, recursive_repo_dirs)
    all_repos = filter_repos(all_repos, exclude_patterns)
    fetch_repos(all_repos)
    print_dirty_repos(base_path, all_repos)

